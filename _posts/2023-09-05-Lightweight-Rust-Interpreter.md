---
layout: post
author: qbb84
tags: [Rust, Interpreter]
---

<i>This is a technical post regarding lri, I will try to provide explanation with example snippets.

lri is a project born out of a desire to deepen my understanding of the Rust programming language. As a passionate developer, I recognized the value of hands-on experience, and building an interpreter provided an excellent opportunity to explore Rust's unique features and challenges.

## 1. What is an Interpreter?

An interpreter is a program that reads and executes code directly, without the need for a separate compilation step. It takes source code as input and interprets it on the fly, executing the instructions one at a time which can be useful for ease of development, portability, dynamic typing, and more.

Some popular languages which commonly use interpreters include:

- Python
- Javascript
- Ruby
- PHP

## 2. Lexical Analysis:

Lexical analysis is the process of breaking the input code into meaningful units called tokens. Tokens are the smallest units of a program, such as keywords, identifiers, literals, and operators. In the context of lri, lexical analysis involves scanning the input Rust code and identifying and categorizing these tokens.

```rust
struct Lexer { input: Vec<char>, position: usize, read_position: usize, ch: char }

impl Lexer {
    pub fn new(input: &str) -> Lexer { Lexer { input: input.chars().collect(), position: 0, read_position: 0, ch: '\0' } }
    fn next_token(&mut self) -> Token { self.skip_whitespace(); let token = match self.ch { '=' => Lexer::new_token(TokenKind::ASSIGN, self.ch), ';' => Lexer::new_token(TokenKind::SEMICOLON, self.ch), '('..='}' => Lexer::new_token(TokenKind::from(self.ch), self.ch), _ => Lexer::classify_token(self.ch), }; self.read_char(); token }
    fn classify_token(ch: char) -> Token { match ch { _ if Lexer::is_letter(ch) => Token { kind: lookup_ident(&self.read_identifier()), literal: String::new() }, _ if Lexer::is_digit(ch) => Token { kind: TokenKind::INT, literal: self.read_number() }, _ => Lexer::new_token(TokenKind::ILLEGAL, ch), } }
}
```

## 3. Parsing

Parsing is the process of taking the stream of tokens generated by lexical analysis and converting it into a structured representation, often represented as an Abstract Syntax Tree (AST). The AST reflects the hierarchical structure of the code and makes it easier to analyze and execute.

```rust
fn parse(tokens: Vec<Token>) -> ASTNode {
    // Implementation of parsing goes here
    // Build an Abstract Syntax Tree (AST) from the tokens
    // Return the root of the AST
}
```

## Work in Progress (WIP)

Given that lri is in its early development stages, this was a showcase of how some of the systems function, in simplistic terms.

Remember, this is a simplified representation, and the actual implementation may involve more complexity, especially considering the features and nuances of the Rust programming language.

You can view the repository <a href="https://github.com/qbb84/lri">here</a>
